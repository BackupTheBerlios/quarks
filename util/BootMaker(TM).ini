#
# Quarks BootMaker(TM) description.
# Required are sections [Bootstrap] and [Root].
#

# Section [Options] contains some options for BootMaker(TM)
# Give a search path where BootMaker(TM) should look for files...
#
[Options]
>searchpath /system

# The [Bootstrap] section contains a description of how to start the system.
# BootMaker(TM) only interprets the >boot command in that it is checked that
# this file is actually included in the image, and then it gets a boot flag
# set in it's inode. That's for the bootsector which wants to know which file
# to start. The bootstrap is also the only file that's stored uncompressed.
# All the rest of this section is ignored by BootMaker(TM), although a copy
# of it is stored in the same directory as the bootstrap as file "boot.ini"
# - to be parsed by the bootstrap itself.
#
# Here the list of commands understood by the bootstrap:
#
#	>boot File
#		Specifies the actual bootstrap file. This is the only file that is 
#		stored uncompressed.
#	>prompt
#		Prompt for possible kernel parameters and/or a bootmenu.
#	>timeout N
#		Wait N seconds before booting the first >startup subsection.
#	>startup "Description" .root=[<naming scheme>]device Processes ...
#		The description is the string showed in a bootmenu.
#		Variable .root specifies the Partition to be mounted as root.
#		The optional <naming scheme> argument tells the bootstrap how to parse
#		the device string. Currently understood are <Linux>, <BeOS>, <BSD> and <QNX>.
#		If left out, Quarks' naming scheme is used. Or just use <probe>
#		to let the bootstrap decide ...
#		Processes is a list of processes that should be started, along with
#		their eventual command line arguments. Should at least be some disk
#		and filesystem drivers. The first entry MUST specify the kernel!
#
# Note that every subsection argument entry must be on a new line except the
# first which may start on the same line as the >command!
#
# After setting up the kernel and all startup processes, control is transferred
# to the kernel. The bootstrap registers itself as a process and once it gets
# rescheduled, it behaves as a normal Quarks process, although not for long.
# The only thing it does is starting init and then exiting gracefully. Job done!!
#
[Bootstrap]
>boot bootstrap
>prompt
>timeout 2
>startup 
	"Quarks 0.1 test..."
	.root=<Linux>/dev/hda1
	kernel_x86
	namer
>startup 
	"Quarks 0.1 failsafe"
	.root=<probe>
	kernel_x86
	namer

# The [Image] section describes the filesystem to be stored in the image.
# It must contain at least the startup files described in [Bootstrap].
# All files are stored without UID/GID. The Quarks image filesystem driver
# treats them all as UID/GID 0 since this is sensible code/data which only root
# should be allowed to modify.
#
#	>dir Path [Files ...]
#		Path specifies the directory to be created in the image.
#		All paths are relative to the last created directory. 
#		Use '/' to specify absolute, just like in real Unix.
#		Files optionally specify the files to be stored within that directory.
#
[Image]
>dir /system
	boot/bootstrap
	kernel/kernel_x86
>dir /system/lib
	lib/quarks/quarks.so.1
	lib/quarks/quarks.so.1.0
>dir /system/servers
	servers/namer/namer
	servers/ide/ide
	servers/vfs/vfs
>dir /system/config
	etc/BootScript
